const char* java_lang = "java.lang.";
EMatchType JPObjectClass::canConvertToJava(HostRef* obj)
{
	JPLocalFrame frame;
	TRACE_IN("JPObjectClass::canConvertToJava");
	if (JPEnv::getHost()->isNone(obj))
	{
		return _implicit;
	}

	const string& simpleName = m_Name.getSimpleName();
	TRACE2("Simple name", simpleName);

	if (JPEnv::getHost()->isObject(obj))
	{
		JPObject* o = JPEnv::getHost()->asObject(obj);
		JPObjectClass* oc = o->getClass(); 
		TRACE2("Match name", oc->m_Name.getSimpleName());

		if (oc == this)
		{
			// hey, this is me! :)
			return _exact;
		}

		if (JPEnv::getJava()->IsAssignableFrom(oc->m_Class, m_Class))
		{
			return _implicit;
		}
	}

	if (simpleName.compare(0, 10, java_lang)==0)
	{
		// Handle a Python class which wraps java class 
		if (simpleName == "java.lang.Class")
		{
			if (JPEnv::getHost()->isClass(obj))
			{
				return _exact;
			}
		}
	
		if (simpleName == "java.lang.Object")
		{
			// arrays are objects
			if (JPEnv::getHost()->isArray(obj))
			{
				TRACE1("From array");
				return _implicit;
			}
	
			// Strings are objects too
			if (JPEnv::getHost()->isString(obj))
			{
				TRACE1("From string");
				return _implicit;
			}
	
			// Class are objects too
			if (JPEnv::getHost()->isClass(obj) || JPEnv::getHost()->isArrayClass(obj))
			{
				TRACE1("implicit array class");
				return _implicit;
			}
	
			// Let'a allow primitives (int, long, float and boolean) to convert implicitly too ...
			if (JPEnv::getHost()->isInt(obj))
			{
				TRACE1("implicit int");
				return _implicit;
			}
	
			if (JPEnv::getHost()->isLong(obj))
			{
				TRACE1("implicit long");
				return _implicit;
			}
	
			if (JPEnv::getHost()->isFloat(obj))
			{
				TRACE1("implicit float");
				return _implicit;
			}
	
			if (JPEnv::getHost()->isBoolean(obj))
			{
				TRACE1("implicit boolean");
				return _implicit;
			}
		}
	}

	if (JPEnv::getHost()->isWrapper(obj))
	{
		JPClass* o = JPEnv::getHost()->getWrapperClass(obj);
		if (o == this)
		{
			TRACE1("exact wrapper");
			return _exact;
		}
	}

	if (JPEnv::getHost()->isProxy(obj))
	{
		JPProxy* proxy = JPEnv::getHost()->asProxy(obj);
		// Check if any of the interfaces matches ...
		vector<jclass> itf = proxy->getInterfaces();
		for (unsigned int i = 0; i < itf.size(); i++)
		{
			if (JPEnv::getJava()->IsAssignableFrom(itf[i], m_Class))
			{
				TRACE1("implicit proxy");
				return _implicit;
			}
		}
	}

	return _none;
	TRACE_OUT;
}

jobject JPObjectClass::buildObjectWrapper(HostRef* obj)
{
	JPLocalFrame frame;

	vector<HostRef*> args(1);
	args.push_back(obj);

	JPObject* pobj = newInstance(args);
	jobject out = pobj->getObject();
	delete pobj;

	return frame.keep(out);
}

jvalue JPObjectClass::convertToJava(HostRef* obj)
{
	TRACE_IN("JPObjectClass::convertToJava");
	JPLocalFrame frame;
	jvalue res;

	res.l = NULL;
	const string& simpleName = m_Name.getSimpleName();

	// assume it is convertible;
	if (JPEnv::getHost()->isNone(obj))
	{
		res.l = NULL;
		return res;
	}

	if (JPEnv::getHost()->isObject(obj))
	{
		JPObject* ref = JPEnv::getHost()->asObject(obj);
		res.l = frame.keep(ref->getObject());
		return res;
	}

	if (simpleName.compare(0, 10, java_lang)==0)
	{
		if (JPEnv::getHost()->isString(obj))
		{
			JPClass* type = JPTypeManager::_java_lang_String;
			res = type->convertToJava(obj);
			res.l = frame.keep(res.l);
			return res;
		}

		if (simpleName == "java.lang.Class")
		{
			JPObjectClass* w = JPEnv::getHost()->asClass(obj);
			jclass lr = w->getNativeClass();
			res.l = lr;
		}

		if (simpleName == "java.lang.Object")
		{
			if (JPEnv::getHost()->isInt(obj))
			{
				JPClass* t = JPTypeManager::_int;
				res.l = frame.keep(t->convertToJavaObject(obj));
				return res;
			}

			else if (JPEnv::getHost()->isLong(obj))
			{
				JPClass* t = JPTypeManager::_long;
				res.l = frame.keep(t->convertToJavaObject(obj));
				return res;
			}

			else if (JPEnv::getHost()->isFloat(obj))
			{
				JPClass* t = JPTypeManager::_double;
				res.l = frame.keep(t->convertToJavaObject(obj));
				return res;
			}

			else if (JPEnv::getHost()->isBoolean(obj))
			{
				JPClass* t = JPTypeManager::_boolean;
				res.l = frame.keep(t->convertToJavaObject(obj));
				return res;
			}

			else if (JPEnv::getHost()->isArray(obj) && simpleName == "java.lang.Object")
			{
				JPArray* a = JPEnv::getHost()->asArray(obj);
				res = a->getValue();
				res.l = frame.keep(res.l);
				return res;
			}

			else if (JPEnv::getHost()->isClass(obj))
			{
				JPClass* type = JPTypeManager::findClass(JPJni::s_ClassClass);
				res.l = frame.keep(type->convertToJavaObject(obj));
				return res;
			}
		}
	}

	if (JPEnv::getHost()->isProxy(obj))
	{
		JPProxy* proxy = JPEnv::getHost()->asProxy(obj);
		res.l = frame.keep(proxy->getProxy());
		return res;
	}

	if (JPEnv::getHost()->isWrapper(obj))
	{
		res = JPEnv::getHost()->getWrapperValue(obj); // FIXME isn't this one global already
		res.l = frame.keep(res.l);
		return res;
	}

	return res;
	TRACE_OUT;
}

